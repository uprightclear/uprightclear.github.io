<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>uprightclear</title>
    <link>uprightclear.github.io/</link>
    <description>Recent content on uprightclear</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>除非特别声明，本站采用[Creative Commons Attribution 4.0 International license](https://creativecommons.org/licenses/by-sa/4.0/).</copyright>
    <lastBuildDate>Thu, 14 May 2020 11:08:28 +0800</lastBuildDate>
    
	<atom:link href="uprightclear.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode 刷题报告 #83</title>
      <link>uprightclear.github.io/2020/05/leetcode19/</link>
      <pubDate>Thu, 14 May 2020 11:08:28 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode19/</guid>
      <description>83.删除排序链表中的重复元素 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。
示例 1:
输入: 1-&amp;gt;1-&amp;gt;2 输出: 1-&amp;gt;2
示例 2:
输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 输出: 1-&amp;gt;2-&amp;gt;3
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list 著作权归领扣网络所有。
题解(Java) /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode current = head; while (current !</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #70</title>
      <link>uprightclear.github.io/2020/05/leetcode18/</link>
      <pubDate>Wed, 13 May 2020 10:23:08 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode18/</guid>
      <description>70.爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
题解(Java) public class Solution { public int climbStairs(int n) { climb_Stairs(0, n); } public int climb_Stairs(int i, int n) { if (i &amp;gt; n) { return 0; } if (i == n) { return 1; } return climb_Stairs(i + 1, n) + climb_Stairs(i + 2, n); } } 思路 在暴力法中，我们将会把所有可能爬的阶数进行组合，也就是 1 和 2 。而在每一步中我们都会继续调用 climbStairsclimbStairs 这个函数模拟爬 11 阶和 22 阶的情形，并返回两个函数的返回值之和。</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #69</title>
      <link>uprightclear.github.io/2020/05/leetcode17/</link>
      <pubDate>Wed, 13 May 2020 10:22:47 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode17/</guid>
      <description>69.x的平方根 实现 int sqrt(int x) 函数。
计算并返回 x 的平方根，其中 x 是非负整数。
由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
示例 1:
输入: 4 输出: 2
示例 2:
输入: 8 输出: 2
说明: 8 的平方根是 2.82842&amp;hellip;, 由于返回类型是整数，小数部分将被舍去。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/sqrtx 著作权归领扣网络所有。
题解(Java) class Solution { public int mySqrt(int x) { if (x == 0) { return 0; } double C = x, x0 = x; while (true) { double xi = 0.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #67</title>
      <link>uprightclear.github.io/2020/05/leetcode16/</link>
      <pubDate>Tue, 12 May 2020 18:11:15 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode16/</guid>
      <description>67.二进制求和 给你两个二进制字符串，返回它们的和（用二进制表示）。
输入为 非空 字符串且只包含数字 1 和 0。
 示例 1:
输入: a = &amp;ldquo;11&amp;rdquo;, b = &amp;ldquo;1&amp;rdquo; 输出: &amp;ldquo;100&amp;rdquo;
示例 2:
输入: a = &amp;ldquo;1010&amp;rdquo;, b = &amp;ldquo;1011&amp;rdquo; 输出: &amp;ldquo;10101&amp;rdquo;
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/add-binary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
题解(Java) import java.math.BigInteger; class Solution { public String addBinary(String a, String b) { BigInteger x = new BigInteger(a, 2); BigInteger y = new BigInteger(b, 2); BigInteger zero = new BigInteger(&amp;#34;0&amp;#34;, 2); BigInteger carry, answer; while (y.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #66</title>
      <link>uprightclear.github.io/2020/05/leetcode15/</link>
      <pubDate>Tue, 12 May 2020 18:10:52 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode15/</guid>
      <description>66.加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。
示例 1:
输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。
示例 2:
输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/plus-one 著作权归领扣网络所有。
题解(Java) class Solution { public int[] plusOne(int[] digits) { int len = digits.length; for(int i = len - 1; i &amp;gt;= 0; i--) { digits[i]++; digits[i] %= 10; if(digits[i]!</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #58</title>
      <link>uprightclear.github.io/2020/05/leetcode14/</link>
      <pubDate>Mon, 11 May 2020 09:21:47 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode14/</guid>
      <description>58.最后一个单词的长度 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。
如果不存在最后一个单词，请返回 0 。
说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。
示例:
输入: &amp;ldquo;Hello World&amp;rdquo; 输出: 5
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/length-of-last-word 著作权归领扣网络所有。
题解(Java) class Solution { public int lengthOfLastWord(String s) { int end = s.length() - 1; while(end &amp;gt;= 0 &amp;amp;&amp;amp; s.charAt(end) == &amp;#39; &amp;#39;) end--; if(end &amp;lt; 0) return 0; int start = end; while(start &amp;gt;= 0 &amp;amp;&amp;amp; s.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #53</title>
      <link>uprightclear.github.io/2020/05/leetcode13/</link>
      <pubDate>Mon, 11 May 2020 09:21:31 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode13/</guid>
      <description>53.最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
题解(Java) class Solution { public int maxSubArray(int[] nums) { int ans = nums[0]; int sum = 0; for(int num: nums) { if(sum &amp;gt; 0) { sum += num; } else { sum = num; } ans = Math.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #38</title>
      <link>uprightclear.github.io/2020/05/leetcode12/</link>
      <pubDate>Sun, 10 May 2020 14:38:05 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode12/</guid>
      <description>38.外观数列 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：
 1 11 21 1211 111221  1 被读作 &amp;ldquo;one 1&amp;rdquo; (&amp;ldquo;一个一&amp;rdquo;) , 即 11。
11 被读作 &amp;ldquo;two 1s&amp;rdquo; (&amp;ldquo;两个一&amp;rdquo;）, 即 21。
21 被读作 &amp;ldquo;one 2&amp;rdquo;, &amp;ldquo;one 1&amp;rdquo; （&amp;ldquo;一个二&amp;rdquo; , &amp;ldquo;一个一&amp;rdquo;) , 即 1211。
给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。
注意：整数序列中的每一项将表示为一个字符串。
 示例 1:</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #35</title>
      <link>uprightclear.github.io/2020/05/leetcode11/</link>
      <pubDate>Sun, 10 May 2020 14:37:47 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode11/</guid>
      <description>35.搜索插入位置 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
示例 1:
输入: [1,3,5,6], 5 输出: 2
示例 2:
输入: [1,3,5,6], 2 输出: 1
示例 3:
输入: [1,3,5,6], 7 输出: 4
示例 4:
输入: [1,3,5,6], 0 输出: 0
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/search-insert-position 著作权归领扣网络所有。
题解(Java) 法1
class Solution { public int searchInsert(int[] nums, int target) { int left = 0, right = nums.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #28</title>
      <link>uprightclear.github.io/2020/05/leetcode10/</link>
      <pubDate>Sat, 09 May 2020 10:44:01 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode10/</guid>
      <description>28.实现 strStr() 实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。
示例 1:
输入: haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo; 输出: 2
示例 2:
输入: haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo; 输出: -1
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/implement-strstr 著作权归领扣网络所有。
题解(Java) class Solution { public int strStr(String haystack, String needle) { int L = needle.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #27</title>
      <link>uprightclear.github.io/2020/05/leetcode09/</link>
      <pubDate>Sat, 09 May 2020 10:42:26 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode09/</guid>
      <description>27.移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
 示例 1:
给定 nums = [3,2,2,3], val = 3,
函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
你不需要考虑数组中超出新长度后面的元素。
示例 2:
给定 nums = [0,1,2,2,3,0,4,2], val = 2,
函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #26</title>
      <link>uprightclear.github.io/2020/05/leetcode08/</link>
      <pubDate>Sat, 09 May 2020 10:27:07 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode08/</guid>
      <description>26. 删除排序数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
示例 1:
给定数组 nums = [1,1,2],
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。
你不需要考虑数组中超出新长度后面的元素。
示例 2:
给定 nums = [0,0,1,1,1,2,2,3,3,4],
函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。
你不需要考虑数组中超出新长度后面的元素。
题解(Java) class Solution { public int removeDuplicates(int[] nums) { if(nums == null || nums.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #21</title>
      <link>uprightclear.github.io/2020/05/leetcode07/</link>
      <pubDate>Fri, 08 May 2020 14:45:15 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode07/</guid>
      <description>21. 合并两个有序链表 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 著作权归领扣网络所有。
题解(Java) /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null) { return l2; } else if (l2 == null) { return l1; } else if (l1.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #20</title>
      <link>uprightclear.github.io/2020/05/leetcode06/</link>
      <pubDate>Fri, 08 May 2020 14:24:17 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode06/</guid>
      <description>20.有效的括号 给定一个只包括 &amp;lsquo;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&amp;rsquo; 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。
示例
   输入 输出     &amp;ldquo;()&amp;rdquo; true   &amp;ldquo;()[]{}&amp;rdquo; true   &amp;ldquo;(]&amp;rdquo; false   &amp;ldquo;{[]}&amp;rdquo; true    来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/valid-parentheses 著作权归领扣网络所有。
题解(Java) class Solution { // Hash table that takes care of the mappings.</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #14</title>
      <link>uprightclear.github.io/2020/05/leetcode05/</link>
      <pubDate>Fri, 08 May 2020 14:10:29 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode05/</guid>
      <description>14.最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。
如果不存在公共前缀，返回空字符串 &amp;ldquo;&amp;quot;。
示例 1:
输入: [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;]
输出: &amp;ldquo;fl&amp;rdquo;
示例 2:
输入: [&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;racecar&amp;rdquo;,&amp;ldquo;car&amp;rdquo;]
输出: &amp;quot;&amp;rdquo;
解释: 输入不存在公共前缀。
说明:
所有输入只包含小写字母 a-z 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/longest-common-prefix 著作权归领扣网络所有。
题解(Java) class Solution { public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return &amp;#34;&amp;#34;; String prefix = strs[0]; for (int i = 1; i &amp;lt; strs.</description>
    </item>
    
    <item>
      <title>Markdown基础语法</title>
      <link>uprightclear.github.io/2020/05/markdown-grammar/</link>
      <pubDate>Thu, 07 May 2020 10:02:26 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/markdown-grammar/</guid>
      <description>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。
相比WYSIWYG编辑器
优点： 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可
缺点： 1、需要记一些语法（当然，是很简单。五分钟学会）。 2、有些平台不支持Markdown编辑模式。
一、标题 在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。
注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。
示例：
# 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题 效果如下：
这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来
斜体 要倾斜的文字左右分别用一个*号包起来
斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来
删除线 要加删除线的文字左右分别用两个~~号包起来
示例：
**这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 效果如下：
这是加粗的文字
这是倾斜的文字`
这是斜体加粗的文字</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #13</title>
      <link>uprightclear.github.io/2020/05/leetcode04/</link>
      <pubDate>Thu, 07 May 2020 08:38:00 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode04/</guid>
      <description>13.罗马数字转整数 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
   字符 数值     I 1   V 5   X 10   L 50   C 100   D 500   M 1000    例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #9</title>
      <link>uprightclear.github.io/2020/05/leetcode03/</link>
      <pubDate>Thu, 07 May 2020 08:11:14 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode03/</guid>
      <description>9.回文数 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
示例 1:
输入: 121 输出: true
示例 2:
输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:
输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。
题解(Java) class Solution { public boolean isPalindrome(int x) { if(x &amp;lt; 0) return false; int cur = 0; int num = x; while(num !</description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #7</title>
      <link>uprightclear.github.io/2020/05/leetcode02/</link>
      <pubDate>Wed, 06 May 2020 08:31:40 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode02/</guid>
      <description>7.整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
示例 1:
输入: 123 输出: 321
示例 2:
输入: -123 输出: -321
示例 3:
输入: 120 输出: 21
注意:
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-integer 著作权归领扣网络所有。
题解(Java) class Solution { public int reverse(int x) { int ans = 0; while (x != 0) { if ((ans * 10) / 10 !</description>
    </item>
    
    <item>
      <title>关于如何更新hugo博客</title>
      <link>uprightclear.github.io/2020/05/update/</link>
      <pubDate>Tue, 05 May 2020 18:06:46 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/update/</guid>
      <description>创建新的markdown文件 hugo new posts/abcd.md 1.该命令执行后会在当前项目文件夹下posts目录中自动生成 abcd.md 文档，并附带文件生成时间等属性
2.完成博客的攥写
启动hugo hugo server 1.该命令用于启动hugo服务器，并生成本地地址
2.在本地浏览器对页面进行预览确定页面显示没有错误
生成public hugo --baseUrl=&amp;#34;uprightclear.github.io/&amp;#34; --buildDrafts 1.更新public文件夹
cd public 2.进入public文件夹
更新代码 1.查看当前的git仓库状态，可以使用git status
git status 2.更新全部
git add * 3.输入git commit -m “更新备注”
git commit -m “更新备注” 4.先git pull,拉取当前分支最新代码（也就是获取GitHub上的最新代码信息，更新本地代码）
git pull 5.push到远程master分支上（修改本地代码后，再更新GitHub上的代码）
git push origin master </description>
    </item>
    
    <item>
      <title>Leetcode 刷题报告 #1</title>
      <link>uprightclear.github.io/2020/05/leetcode01/</link>
      <pubDate>Tue, 05 May 2020 17:09:06 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/05/leetcode01/</guid>
      <description>1.两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
示例:
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 著作权归领扣网络所有。
题解(Java) class Solution {public int[] twoSum(int[] nums, int target) {Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();for (int i = 0; i &amp;lt; nums.</description>
    </item>
    
    <item>
      <title>联系</title>
      <link>uprightclear.github.io/%E8%81%94%E7%B3%BB/</link>
      <pubDate>Mon, 24 Feb 2020 12:35:25 +0800</pubDate>
      
      <guid>uprightclear.github.io/%E8%81%94%E7%B3%BB/</guid>
      <description>邮箱:uprightclear@gmail.com
微博:https://weibo.com/uprightclear
B站:https://space.bilibili.com/10095445</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>uprightclear.github.io/%E5%85%B3%E4%BA%8E/</link>
      <pubDate>Mon, 24 Feb 2020 12:34:51 +0800</pubDate>
      
      <guid>uprightclear.github.io/%E5%85%B3%E4%BA%8E/</guid>
      <description>uprightclear的个人主页 分享技术/分享生活</description>
    </item>
    
    <item>
      <title>My First Blog</title>
      <link>uprightclear.github.io/2020/02/my-first-blog/</link>
      <pubDate>Mon, 24 Feb 2020 11:30:04 +0800</pubDate>
      
      <guid>uprightclear.github.io/2020/02/my-first-blog/</guid>
      <description>这个博客主要就是用来记录一下我的学习历程，偶尔可能会写一些其他杂七杂八的东西。还有markdown格式我还是需要再好好研究一下QAQ。</description>
    </item>
    
  </channel>
</rss>